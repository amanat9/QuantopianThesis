# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1g7SzxJvSjLlBMBPR7uJ48YbxoWCVzJbG
"""

from collections import OrderedDict
from time import time

import pandas as pd
import numpy as np
from sklearn import ensemble, preprocessing, metrics, linear_model


#My Imports
#from sklearn.ensemble import RandomForestClassifier as rf
from sklearn.tree import DecisionTreeClassifier as DTC
from sklearn.naive_bayes import GaussianNB , BernoulliNB
from sklearn.linear_model import LogisticRegression
from sklearn.linear_model import SGDClassifier as sgdc
from sklearn.feature_selection import f_regression ,f_classif
from sklearn.feature_selection import SelectKBest
#My Imports End



from quantopian.algorithm import (
    attach_pipeline,
    date_rules,
    order_optimal_portfolio,
    pipeline_output,
    record,
    schedule_function,
    set_commission,
    set_slippage,
    time_rules,
)

# NOTE BOOK IMPORTS

from quantopian.pipeline.factors import Latest
from quantopian.pipeline.data import morningstar
from quantopian.pipeline.factors import (
    AnnualizedVolatility,
    Aroon, # not working here
    AverageDollarVolume,
    BollingerBands,
    FastStochasticOscillator,
    MarketCap,
    MovingAverageConvergenceDivergenceSignal,
    TrueRange,
    VWAP,
    WeightedAverageValue,
    CustomFactor,
    SimpleMovingAverage,
    AverageDollarVolume,
    Returns,
    RSI,
    EWMA
        
)
from quantopian.pipeline.classifiers.morningstar import Sector
from quantopian.pipeline.data.quandl import fred_usdontd156n as libor
# from quantopian.pipeline.data.zacks import EarningsSurprises

import talib

# import alphalens as al
# import pyfolio as pf
from scipy import stats
from sklearn import decomposition, isotonic


# NOTE BOOK IMPORTS


import quantopian.optimize as opt
from quantopian.pipeline import Pipeline
from quantopian.pipeline.classifiers.fundamentals import Sector as _Sector
from quantopian.pipeline.data import Fundamentals
from quantopian.pipeline.data.builtin import USEquityPricing

# HELLOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO

from quantopian.pipeline.data.builtin import USEquityPricing
from quantopian.pipeline.filters import QTradableStocksUS
from quantopian.pipeline.filters import Q500US
import quantopian.pipeline.factors as Factors

# HELLOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO

from quantopian.pipeline.factors import (
    CustomFactor,
    Returns,
    MACDSignal,
)
from quantopian.pipeline.filters.fundamentals import Q1500US
from zipline.utils.numpy_utils import (
    repeat_first_axis,
    repeat_last_axis,
)

# If you have eventvestor, it's a good idea to screen out aquisition targets
# Comment out & ~IsAnnouncedAcqTarget() as well. You can also run this over
# the free period.
# from quantopian.pipeline.filters.eventvestor import IsAnnouncedAcqTarget

# Will be split 50% long and 50% short
N_STOCKS_TO_TRADE = 500

# Number of days to train the classifier on, easy to run out of memory here
ML_TRAINING_WINDOW = 200

# train on returns over N days into the future
PRED_N_FORWARD_DAYS = 1

# How often to trade, for daily, set to date_rules.every_day()
TRADE_FREQ = date_rules.every_day()
#date_rules.every_day()
    # THESE ARE MY CUSTOM TALIB FACTORS
    
    
# THESE ARE MY CUSTOM TALIB FACTORS



"""
HELPER FUNCTIONS
"""


# asset_growth_3m = Returns(
#     inputs=[Fundamentals.total_assets],
#     window_length=63,
# )
# asset_to_equity_ratio = (
#     Fundamentals.total_assets.latest /
#     Fundamentals.common_stock_equity.latest
# )
# capex_to_cashflows = (
#     Fundamentals.capital_expenditure.latest /
#     Fundamentals.free_cash_flow.latest
# )

# ebitda_yield = (
#     (Fundamentals.ebitda.latest * 4) /
#     USEquityPricing.close.latest
# )
# ebita_to_assets = (
#     (Fundamentals.ebit.latest * 4) /
#     Fundamentals.total_assets.latest
# )
# return_on_total_invest_capital = Fundamentals.roic.latest
# mean_reversion_1m = MeanReversion1M()
# macd_signal_10d = MACDSignal(
#     fast_period=12,
#     slow_period=26,
#     signal_period=10,
# )
# moneyflow_volume_5d = MoneyflowVolume5d()
# net_income_margin = Fundamentals.net_margin.latest
# operating_cashflows_to_assets = (
#     (Fundamentals.operating_cash_flow.latest * 4) /
#     Fundamentals.total_assets.latest
# )
# price_momentum_3m = Returns(window_length=63)
# price_oscillator = PriceOscillator()
# trendline = Trendline()
# returns_39w = Returns(window_length=215)
# volatility_3m = Volatility3M()
# advanced_momentum = AdvancedMomentum()


class helper:
    default_feature = []
    reduced_columns = []


# NOTE BOOK FACTORS HERE


bs = morningstar.balance_sheet
cfs = morningstar.cash_flow_statement
is_ = morningstar.income_statement
or_ = morningstar.operation_ratios
er = morningstar.earnings_report
v = morningstar.valuation
vr = morningstar.valuation_ratios



def Asset_Growth_3M():
    return Returns(inputs=[bs.total_assets], window_length=63)

def Asset_Growth_2D():
    return Returns(inputs=[bs.total_assets], window_length=2)

def Asset_Growth_5D():
    return Returns(inputs=[bs.total_assets], window_length=5)

def Asset_Growth_22D():
    return Returns(inputs=[bs.total_assets], window_length=22)



def Asset_To_Equity_Ratio():
    return bs.total_assets.latest / bs.common_stock_equity.latest

def Capex_To_Cashflows():
    return (cfs.capital_expenditure.latest * 4.) / \
        (cfs.free_cash_flow.latest * 4.)

def EBITDA_Yield():
    return (is_.ebitda.latest * 4.) / \
        USEquityPricing.close.latest        

def EBIT_To_Assets():
    return (is_.ebit.latest * 4.) / \
        bs.total_assets.latest

def Earnings_Quality():
    return morningstar.cash_flow_statement.operating_cash_flow.latest / \
           EarningsSurprises.eps_act.latest

def Return_On_Total_Invest_Capital():
    return or_.roic.latest
#mamalol
class Mean_Reversion_1M(CustomFactor):
    inputs = [Returns(window_length=21)]
    window_length = 252

    def compute(self, today, assets, out, monthly_rets):
        out[:] = (monthly_rets[-1] - np.nanmean(monthly_rets, axis=0)) / \
            np.nanstd(monthly_rets, axis=0)

class Mean_Reversion_2D(CustomFactor):
    inputs = [Returns(window_length=2)]
    window_length = 252

    def compute(self, today, assets, out, monthly_rets):
        out[:] = (monthly_rets[-1] - np.nanmean(monthly_rets, axis=0)) / \
            np.nanstd(monthly_rets, axis=0)
class Mean_Reversion_5D(CustomFactor):
    inputs = [Returns(window_length=5)]
    window_length = 252

    def compute(self, today, assets, out, monthly_rets):
        out[:] = (monthly_rets[-1] - np.nanmean(monthly_rets, axis=0)) / \
            np.nanstd(monthly_rets, axis=0)

class Mean_Reversion_6D(CustomFactor):
    inputs = [Returns(window_length=6)]
    window_length = 252

    def compute(self, today, assets, out, monthly_rets):
        out[:] = (monthly_rets[-1] - np.nanmean(monthly_rets, axis=0)) / \
            np.nanstd(monthly_rets, axis=0)

class MACD_Signal_10d(CustomFactor):
    inputs = [USEquityPricing.close]
    window_length = 60

    def compute(self, today, assets, out, close):

        sig_lines = []

        for col in close.T:
            # get signal line only
            try:
                _, signal_line, _ = talib.MACD(col, fastperiod=12,
                                               slowperiod=26, signalperiod=10)
                sig_lines.append(signal_line[-1])
            # if error calculating, return NaN
            except:
                sig_lines.append(np.nan)
        out[:] = sig_lines 

class MACD_Signal_1d(CustomFactor):
    inputs = [USEquityPricing.close]
    window_length = 1

    def compute(self, today, assets, out, close):

        sig_lines = []

        for col in close.T:
            # get signal line only
            try:
                _, signal_line, _ = talib.MACD(col, fastperiod=12,
                                               slowperiod=26, signalperiod=10)
                sig_lines.append(signal_line[-1])
            # if error calculating, return NaN
            except:
                sig_lines.append(np.nan)
        out[:] = sig_lines 

class MACD_Signal_2d(CustomFactor):
    inputs = [USEquityPricing.close]
    window_length = 2

    def compute(self, today, assets, out, close):

        sig_lines = []

        for col in close.T:
            # get signal line only
            try:
                _, signal_line, _ = talib.MACD(col, fastperiod=12,
                                               slowperiod=26, signalperiod=10)
                sig_lines.append(signal_line[-1])
            # if error calculating, return NaN
            except:
                sig_lines.append(np.nan)
        out[:] = sig_lines 


class MACD_Signal_5d(CustomFactor):
    inputs = [USEquityPricing.close]
    window_length = 5

    def compute(self, today, assets, out, close):

        sig_lines = []

        for col in close.T:
            # get signal line only
            try:
                _, signal_line, _ = talib.MACD(col, fastperiod=12,
                                               slowperiod=26, signalperiod=10)
                sig_lines.append(signal_line[-1])
            # if error calculating, return NaN
            except:
                sig_lines.append(np.nan)
        out[:] = sig_lines 


class MACD_Signal_22d(CustomFactor):
    inputs = [USEquityPricing.close]
    window_length = 22

    def compute(self, today, assets, out, close):

        sig_lines = []

        for col in close.T:
            # get signal line only
            try:
                _, signal_line, _ = talib.MACD(col, fastperiod=12,
                                               slowperiod=26, signalperiod=10)
                sig_lines.append(signal_line[-1])
            # if error calculating, return NaN
            except:
                sig_lines.append(np.nan)
        out[:] = sig_lines 

# THESE ARE MY CUSTOM TALIB FACTORS



"""
HELPER FUNCTIONS
"""

def plus_dm_helper(high, low):
    """
    Returns positive directional movement. Abstracted for use with more complex factors

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI

    Parameters
    ----------
    high : np.array
        matrix of high prices
    low : np.array
        matrix of low prices

    Returns
    -------
    np.array : matrix of positive directional movement

    """
    # get daily differences between high prices
    high_diff = (high - np.roll(high, 1, axis=0))[1:]

    # get daily differences between low prices
    low_diff = (np.roll(low, 1, axis=0) - low)[1:]

    # matrix of positive directional movement
    return np.where(((high_diff > 0) | (low_diff > 0)) & (high_diff > low_diff), high_diff, 0.)

def minus_dm_helper(high, low):
    """
    Returns negative directional movement. Abstracted for use with more complex factors

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI

    Parameters
    ----------
    high : np.array
        matrix of high prices
    low : np.array
        matrix of low prices

    Returns
    -------
    np.array : matrix of negative directional movement

    """
    # get daily differences between high prices
    high_diff = (high - np.roll(high, 1, axis=0))[1:]

    # get daily differences between low prices
    low_diff = (np.roll(low, 1, axis=0) - low)[1:]

    # matrix of megative directional movement
    return np.where(((high_diff > 0) | (low_diff > 0)) & (high_diff < low_diff), low_diff, 0.)


def trange_helper(high, low, close):
    """
    Returns true range

    http://www.macroption.com/true-range/

    Parameters
    ----------
    high : np.array
        matrix of high prices
    low : np.array
        matrix of low prices
    close: np.array
        matrix of close prices

    Returns
    -------
    np.array : matrix of true range

    """
    # define matrices to be compared
    close = close[:-1]
    high = high[1:]
    low = low[1:]

    # matrices for comparison
    high_less_close = high - close
    close_less_low = close - low
    high_less_low = high - low

    # return maximum value for each cel
    return np.maximum(high_less_close, close_less_low, high_less_low)


"""
Techincal Analysis Indicators
"""


class AD(CustomFactor):
    """
    Chaikin Accumulation Distribution Line

    Volume indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquitypricing.close, USEquityPricing.volume

    **Default Window Length:** 14

    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:accumulation_distribution_line
    """        
    inputs = [USEquityPricing.close, USEquityPricing.high, USEquityPricing.low, USEquityPricing.volume]
    window_length = 14

    def compute(self, today, assets, out, close, high, low, vol):

        # close location value
        clv = ((close - low) - (high - close)) / (high - low)
        ad = clv * vol
        out[:] =  np.sum(ad, axis=0)


class AD_1D(CustomFactor):
    """
    Chaikin Accumulation Distribution Line

    Volume indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquitypricing.close, USEquityPricing.volume

    **Default Window Length:** 14

    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:accumulation_distribution_line
    """        
    inputs = [USEquityPricing.close, USEquityPricing.high, USEquityPricing.low, USEquityPricing.volume]
    window_length = 1

    def compute(self, today, assets, out, close, high, low, vol):

        # close location value
        clv = ((close - low) - (high - close)) / (high - low)
        ad = clv * vol
        out[:] =  np.sum(ad, axis=0)

class AD_2D(CustomFactor):
    """
    Chaikin Accumulation Distribution Line

    Volume indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquitypricing.close, USEquityPricing.volume

    **Default Window Length:** 14

    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:accumulation_distribution_line
    """        
    inputs = [USEquityPricing.close, USEquityPricing.high, USEquityPricing.low, USEquityPricing.volume]
    window_length = 2

    def compute(self, today, assets, out, close, high, low, vol):

        # close location value
        clv = ((close - low) - (high - close)) / (high - low)
        ad = clv * vol
        out[:] =  np.sum(ad, axis=0)  

class AD_5D(CustomFactor):
    """
    Chaikin Accumulation Distribution Line

    Volume indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquitypricing.close, USEquityPricing.volume

    **Default Window Length:** 14

    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:accumulation_distribution_line
    """        
    inputs = [USEquityPricing.close, USEquityPricing.high, USEquityPricing.low, USEquityPricing.volume]
    window_length = 5

    def compute(self, today, assets, out, close, high, low, vol):

        # close location value
        clv = ((close - low) - (high - close)) / (high - low)
        ad = clv * vol
        out[:] =  np.sum(ad, axis=0)

class AD_22D(CustomFactor):
    """
    Chaikin Accumulation Distribution Line

    Volume indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquitypricing.close, USEquityPricing.volume

    **Default Window Length:** 14

    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:accumulation_distribution_line
    """        
    inputs = [USEquityPricing.close, USEquityPricing.high, USEquityPricing.low, USEquityPricing.volume]
    window_length = 22

    def compute(self, today, assets, out, close, high, low, vol):

        # close location value
        clv = ((close - low) - (high - close)) / (high - low)
        ad = clv * vol
        out[:] =  np.sum(ad, axis=0)


class ADX(CustomFactor):
    """
    Average Directional Movement Index

    Momentum indicator. Smoothed DX

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquitypricing.close

    **Default Window Length:** 29

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """        
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 29

    def compute(self, today, assets, out, high, low, close):

        # positive directional index
        plus_di = 100 * np.cumsum(plus_dm_helper(high, low) / trange_helper(high, low, close), axis=0)

        # negative directional index
        minus_di = 100 * np.cumsum(minus_dm_helper(high, low) / trange_helper(high, low, close), axis=0)

        # full dx with 15 day burn-in period
        dx_frame = (np.abs(plus_di - minus_di) / (plus_di + minus_di) * 100.)[14:]

        # 14-day EMA
        span = 14.
        decay_rate = 2. / (span + 1.)
        weights = weights_long = np.full(span, decay_rate, float) ** np.arange(span + 1, 1, -1)

        # return EMA
        out[:] = np.average(dx_frame, axis=0, weights=weights)


class ADX_1D(CustomFactor):
    """
    Average Directional Movement Index

    Momentum indicator. Smoothed DX

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquitypricing.close

    **Default Window Length:** 29

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """        
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 1

    def compute(self, today, assets, out, high, low, close):

        # positive directional index
        plus_di = 100 * np.cumsum(plus_dm_helper(high, low) / trange_helper(high, low, close), axis=0)

        # negative directional index
        minus_di = 100 * np.cumsum(minus_dm_helper(high, low) / trange_helper(high, low, close), axis=0)

        # full dx with 15 day burn-in period
        dx_frame = (np.abs(plus_di - minus_di) / (plus_di + minus_di) * 100.)[14:]

        # 14-day EMA
        span = 14.
        decay_rate = 2. / (span + 1.)
        weights = weights_long = np.full(span, decay_rate, float) ** np.arange(span + 1, 1, -1)

        # return EMA
        out[:] = np.average(dx_frame, axis=0, weights=weights)


class ADX_2D(CustomFactor):
    """
    Average Directional Movement Index

    Momentum indicator. Smoothed DX

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquitypricing.close

    **Default Window Length:** 29

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """        
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 2

    def compute(self, today, assets, out, high, low, close):

        # positive directional index
        plus_di = 100 * np.cumsum(plus_dm_helper(high, low) / trange_helper(high, low, close), axis=0)

        # negative directional index
        minus_di = 100 * np.cumsum(minus_dm_helper(high, low) / trange_helper(high, low, close), axis=0)

        # full dx with 15 day burn-in period
        dx_frame = (np.abs(plus_di - minus_di) / (plus_di + minus_di) * 100.)[14:]

        # 14-day EMA
        span = 14.
        decay_rate = 2. / (span + 1.)
        weights = weights_long = np.full(span, decay_rate, float) ** np.arange(span + 1, 1, -1)

        # return EMA
        out[:] = np.average(dx_frame, axis=0, weights=weights)


class ADX_5D(CustomFactor):
    """
    Average Directional Movement Index

    Momentum indicator. Smoothed DX

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquitypricing.close

    **Default Window Length:** 29

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """        
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 5

    def compute(self, today, assets, out, high, low, close):

        # positive directional index
        plus_di = 100 * np.cumsum(plus_dm_helper(high, low) / trange_helper(high, low, close), axis=0)

        # negative directional index
        minus_di = 100 * np.cumsum(minus_dm_helper(high, low) / trange_helper(high, low, close), axis=0)

        # full dx with 15 day burn-in period
        dx_frame = (np.abs(plus_di - minus_di) / (plus_di + minus_di) * 100.)[14:]

        # 14-day EMA
        span = 14.
        decay_rate = 2. / (span + 1.)
        weights = weights_long = np.full(span, decay_rate, float) ** np.arange(span + 1, 1, -1)

        # return EMA
        out[:] = np.average(dx_frame, axis=0, weights=weights)

class ADX_22D(CustomFactor):
    """
    Average Directional Movement Index

    Momentum indicator. Smoothed DX

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquitypricing.close

    **Default Window Length:** 29

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """        
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 22

    def compute(self, today, assets, out, high, low, close):

        # positive directional index
        plus_di = 100 * np.cumsum(plus_dm_helper(high, low) / trange_helper(high, low, close), axis=0)

        # negative directional index
        minus_di = 100 * np.cumsum(minus_dm_helper(high, low) / trange_helper(high, low, close), axis=0)

        # full dx with 15 day burn-in period
        dx_frame = (np.abs(plus_di - minus_di) / (plus_di + minus_di) * 100.)[14:]

        # 14-day EMA
        span = 14.
        decay_rate = 2. / (span + 1.)
        weights = weights_long = np.full(span, decay_rate, float) ** np.arange(span + 1, 1, -1)

        # return EMA
        out[:] = np.average(dx_frame, axis=0, weights=weights)


def APO(shortperiod=12, longperiod=26):
    """
    Absolute Price Oscillator

    Momentum indeicator. Difference between EWMAs (exponential weighted moving averages) of 
    short and long periods.

    **Default Inputs:** 12, 26

    **Default Window Length:** 46 (26 + 20-day burn-in)

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/apo

    Parameters
    ----------
    shortperiod : int > 0
        window length for short EWMA
    longperiod : int > 0 (>= shortperiod)
        window length for longer EWMA

    Returns
    -------
    zipline.Factor
    """
    buffer_window = longperiod + 20

    fast = EWMA.from_span(inputs=[USEquityPricing.close], window_length=buffer_window, span=shortperiod)
    slow = EWMA.from_span(inputs=[USEquityPricing.close], window_length=buffer_window, span=longperiod) 
    return fast - slow


class ATR(CustomFactor):
    """
    Average True Range

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquityPricing.close

    **Default Window Length:** 15 (14+1)

    https://en.wikipedia.org/wiki/Average_true_range
    """
    inputs=[USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 15

    def compute(self, today, assets, out, high, low, close):

        tr_frame = trange_helper(high, low, close)
        decay_rate= 2./(len(tr_frame) + 1.)
        weights = np.full(len(tr_frame), decay_rate, float) ** np.arange(len(tr_frame) + 1, 1, -1)
        out[:] = np.average(tr_frame, axis=0, weights=weights)

class ATR2(CustomFactor):
    """
    Average True Range

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquityPricing.close

    **Default Window Length:** 15 (14+1)

    https://en.wikipedia.org/wiki/Average_true_range
    """
    inputs=[USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 2

    def compute(self, today, assets, out, high, low, close):

        tr_frame = trange_helper(high, low, close)
        decay_rate= 2./(len(tr_frame) + 1.)
        weights = np.full(len(tr_frame), decay_rate, float) ** np.arange(len(tr_frame) + 1, 1, -1)
        out[:] = np.average(tr_frame, axis=0, weights=weights)
class ATR5(CustomFactor):
    """
    Average True Range

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquityPricing.close

    **Default Window Length:** 15 (14+1)

    https://en.wikipedia.org/wiki/Average_true_range
    """
    inputs=[USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 5

    def compute(self, today, assets, out, high, low, close):

        tr_frame = trange_helper(high, low, close)
        decay_rate= 2./(len(tr_frame) + 1.)
        weights = np.full(len(tr_frame), decay_rate, float) ** np.arange(len(tr_frame) + 1, 1, -1)
        out[:] = np.average(tr_frame, axis=0, weights=weights)
class ATR22(CustomFactor):
    """
    Average True Range

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquityPricing.close

    **Default Window Length:** 15 (14+1)

    https://en.wikipedia.org/wiki/Average_true_range
    """
    inputs=[USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 22

    def compute(self, today, assets, out, high, low, close):

        tr_frame = trange_helper(high, low, close)
        decay_rate= 2./(len(tr_frame) + 1.)
        weights = np.full(len(tr_frame), decay_rate, float) ** np.arange(len(tr_frame) + 1, 1, -1)
        out[:] = np.average(tr_frame, axis=0, weights=weights)


class BETA(CustomFactor):
    """
    Market Beta (returns)

    **Default Inputs:** USEquityPricing.close

    **Default Window Length:** 6

    https://en.wikipedia.org/wiki/Beta_(finance)
    """

    inputs=[USEquityPricing.close]
    window_length = 6

    def compute(self, today, assets, out, close):

        # get returns dataset
        returns = ((close - np.roll(close, 1, axis=0)) / np.roll(close, 1, axis=0))[1:]

        # get index of benchmark
        benchmark_index = np.where((assets == 8554) == True)[0][0]

        # get returns of benchmark
        benchmark_returns = returns[:, benchmark_index]

        # prepare X matrix (x_is - x_bar)
        X = benchmark_returns
        X_bar = np.nanmean(X)
        X_vector = X - X_bar
        X_matrix = np.tile(X_vector, (len(returns.T), 1)).T

        # prepare Y matrix (y_is - y_bar)
        Y_bar = np.nanmean(close, axis=0)
        Y_bars = np.tile(Y_bar, (len(returns), 1))
        Y_matrix = returns - Y_bars

        # prepare variance of X
        X_var = np.nanvar(X)

        # multiply X matrix an Y matrix and sum (dot product)
        # then divide by variance of X
        # this gives the MLE of Beta
        out[:] = (np.sum((X_matrix * Y_matrix), axis=0) / X_var) / (len(returns))


class BETA_1D(CustomFactor):
    """
    Market Beta (returns)

    **Default Inputs:** USEquityPricing.close

    **Default Window Length:** 6

    https://en.wikipedia.org/wiki/Beta_(finance)
    """

    inputs=[USEquityPricing.close]
    window_length = 1

    def compute(self, today, assets, out, close):

        # get returns dataset
        returns = ((close - np.roll(close, 1, axis=0)) / np.roll(close, 1, axis=0))[1:]

        # get index of benchmark
        benchmark_index = np.where((assets == 8554) == True)[0][0]

        # get returns of benchmark
        benchmark_returns = returns[:, benchmark_index]

        # prepare X matrix (x_is - x_bar)
        X = benchmark_returns
        X_bar = np.nanmean(X)
        X_vector = X - X_bar
        X_matrix = np.tile(X_vector, (len(returns.T), 1)).T

        # prepare Y matrix (y_is - y_bar)
        Y_bar = np.nanmean(close, axis=0)
        Y_bars = np.tile(Y_bar, (len(returns), 1))
        Y_matrix = returns - Y_bars

        # prepare variance of X
        X_var = np.nanvar(X)

        # multiply X matrix an Y matrix and sum (dot product)
        # then divide by variance of X
        # this gives the MLE of Beta
        out[:] = (np.sum((X_matrix * Y_matrix), axis=0) / X_var) / (len(returns))


class BETA_2D(CustomFactor):
    """
    Market Beta (returns)

    **Default Inputs:** USEquityPricing.close

    **Default Window Length:** 6

    https://en.wikipedia.org/wiki/Beta_(finance)
    """

    inputs=[USEquityPricing.close]
    window_length = 2

    def compute(self, today, assets, out, close):

        # get returns dataset
        returns = ((close - np.roll(close, 1, axis=0)) / np.roll(close, 1, axis=0))[1:]

        # get index of benchmark
        benchmark_index = np.where((assets == 8554) == True)[0][0]

        # get returns of benchmark
        benchmark_returns = returns[:, benchmark_index]

        # prepare X matrix (x_is - x_bar)
        X = benchmark_returns
        X_bar = np.nanmean(X)
        X_vector = X - X_bar
        X_matrix = np.tile(X_vector, (len(returns.T), 1)).T

        # prepare Y matrix (y_is - y_bar)
        Y_bar = np.nanmean(close, axis=0)
        Y_bars = np.tile(Y_bar, (len(returns), 1))
        Y_matrix = returns - Y_bars

        # prepare variance of X
        X_var = np.nanvar(X)

        # multiply X matrix an Y matrix and sum (dot product)
        # then divide by variance of X
        # this gives the MLE of Beta
        out[:] = (np.sum((X_matrix * Y_matrix), axis=0) / X_var) / (len(returns))


class BETA_5D(CustomFactor):
    """
    Market Beta (returns)

    **Default Inputs:** USEquityPricing.close

    **Default Window Length:** 6

    https://en.wikipedia.org/wiki/Beta_(finance)
    """

    inputs=[USEquityPricing.close]
    window_length = 5

    def compute(self, today, assets, out, close):

        # get returns dataset
        returns = ((close - np.roll(close, 1, axis=0)) / np.roll(close, 1, axis=0))[1:]

        # get index of benchmark
        benchmark_index = np.where((assets == 8554) == True)[0][0]

        # get returns of benchmark
        benchmark_returns = returns[:, benchmark_index]

        # prepare X matrix (x_is - x_bar)
        X = benchmark_returns
        X_bar = np.nanmean(X)
        X_vector = X - X_bar
        X_matrix = np.tile(X_vector, (len(returns.T), 1)).T

        # prepare Y matrix (y_is - y_bar)
        Y_bar = np.nanmean(close, axis=0)
        Y_bars = np.tile(Y_bar, (len(returns), 1))
        Y_matrix = returns - Y_bars

        # prepare variance of X
        X_var = np.nanvar(X)

        # multiply X matrix an Y matrix and sum (dot product)
        # then divide by variance of X
        # this gives the MLE of Beta
        out[:] = (np.sum((X_matrix * Y_matrix), axis=0) / X_var) / (len(returns))


class BETA_22D(CustomFactor):
    """
    Market Beta (returns)

    **Default Inputs:** USEquityPricing.close

    **Default Window Length:** 6

    https://en.wikipedia.org/wiki/Beta_(finance)
    """

    inputs=[USEquityPricing.close]
    window_length = 22

    def compute(self, today, assets, out, close):

        # get returns dataset
        returns = ((close - np.roll(close, 1, axis=0)) / np.roll(close, 1, axis=0))[1:]

        # get index of benchmark
        benchmark_index = np.where((assets == 8554) == True)[0][0]

        # get returns of benchmark
        benchmark_returns = returns[:, benchmark_index]

        # prepare X matrix (x_is - x_bar)
        X = benchmark_returns
        X_bar = np.nanmean(X)
        X_vector = X - X_bar
        X_matrix = np.tile(X_vector, (len(returns.T), 1)).T

        # prepare Y matrix (y_is - y_bar)
        Y_bar = np.nanmean(close, axis=0)
        Y_bars = np.tile(Y_bar, (len(returns), 1))
        Y_matrix = returns - Y_bars

        # prepare variance of X
        X_var = np.nanvar(X)

        # multiply X matrix an Y matrix and sum (dot product)
        # then divide by variance of X
        # this gives the MLE of Beta
        out[:] = (np.sum((X_matrix * Y_matrix), axis=0) / X_var) / (len(returns))


class BOP(CustomFactor):
    """
    Balance of Power

    Momentum indicator

    **Default Inputs:** USEquityPricing.close, USEquityPricing.open, USEquityPricing.high, USEquityPricing.low

    **Default Window Length:** 1

    https://www.interactivebrokers.com/en/software/tws/usersguidebook/technicalanalytics/balancepower.htm
    """
    inputs = [USEquityPricing.close, USEquityPricing.open, USEquityPricing.high, USEquityPricing.low]
    window_length = 1

    def compute(self, today, assets, out, close, open, high, low):
        out[:] = (close - open) / (high - low)


class CCI(CustomFactor):
    """
    Commodity Channel Index

    Momentum indicator

    **Default Inputs:** USEquityPricing.close, USEquityPricing.high, USEquityPricing.low

    **Default Window Length:** 14

    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:commodity_channel_index_cci
    """

    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 14

    def compute(self, today, assets, out, high, low, close):

        # typical price matrix
        typical_prices = (high + low + close) / 3.

        # mean of each column
        mean_typical = np.nanmean(typical_prices, axis=0)

        # mean deviation
        mean_deviation = np.sum(np.abs(typical_prices - np.tile(mean_typical, (len(typical_prices), 1))), axis=0) / self.window_length

        # CCI
        out[:] = (typical_prices[-1] - mean_typical) / (.015 * mean_deviation)



class CCI_1D(CustomFactor):
    """
    Commodity Channel Index

    Momentum indicator

    **Default Inputs:** USEquityPricing.close, USEquityPricing.high, USEquityPricing.low

    **Default Window Length:** 14

    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:commodity_channel_index_cci
    """

    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 1

    def compute(self, today, assets, out, high, low, close):

        # typical price matrix
        typical_prices = (high + low + close) / 3.

        # mean of each column
        mean_typical = np.nanmean(typical_prices, axis=0)

        # mean deviation
        mean_deviation = np.sum(np.abs(typical_prices - np.tile(mean_typical, (len(typical_prices), 1))), axis=0) / self.window_length

        # CCI
        out[:] = (typical_prices[-1] - mean_typical) / (.015 * mean_deviation)

class CCI_2D(CustomFactor):
    """
    Commodity Channel Index

    Momentum indicator

    **Default Inputs:** USEquityPricing.close, USEquityPricing.high, USEquityPricing.low

    **Default Window Length:** 14

    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:commodity_channel_index_cci
    """

    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 2

    def compute(self, today, assets, out, high, low, close):

        # typical price matrix
        typical_prices = (high + low + close) / 3.

        # mean of each column
        mean_typical = np.nanmean(typical_prices, axis=0)

        # mean deviation
        mean_deviation = np.sum(np.abs(typical_prices - np.tile(mean_typical, (len(typical_prices), 1))), axis=0) / self.window_length

        # CCI
        out[:] = (typical_prices[-1] - mean_typical) / (.015 * mean_deviation)


class CCI_5D(CustomFactor):
    """
    Commodity Channel Index

    Momentum indicator

    **Default Inputs:** USEquityPricing.close, USEquityPricing.high, USEquityPricing.low

    **Default Window Length:** 14

    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:commodity_channel_index_cci
    """

    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 5

    def compute(self, today, assets, out, high, low, close):

        # typical price matrix
        typical_prices = (high + low + close) / 3.

        # mean of each column
        mean_typical = np.nanmean(typical_prices, axis=0)

        # mean deviation
        mean_deviation = np.sum(np.abs(typical_prices - np.tile(mean_typical, (len(typical_prices), 1))), axis=0) / self.window_length

        # CCI
        out[:] = (typical_prices[-1] - mean_typical) / (.015 * mean_deviation)


class CCI_22D(CustomFactor):
    """
    Commodity Channel Index

    Momentum indicator

    **Default Inputs:** USEquityPricing.close, USEquityPricing.high, USEquityPricing.low

    **Default Window Length:** 14

    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:commodity_channel_index_cci
    """

    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 22

    def compute(self, today, assets, out, high, low, close):

        # typical price matrix
        typical_prices = (high + low + close) / 3.

        # mean of each column
        mean_typical = np.nanmean(typical_prices, axis=0)

        # mean deviation
        mean_deviation = np.sum(np.abs(typical_prices - np.tile(mean_typical, (len(typical_prices), 1))), axis=0) / self.window_length

        # CCI
        out[:] = (typical_prices[-1] - mean_typical) / (.015 * mean_deviation)


class CMO(CustomFactor):
    """
    Chande Momentum Oscillator

    Momentum indicator. Descriptor of overought/oversold conditions

    **Default Inputs:** USEquityPricing.close

    **Default Window Length:** 15 (14 + 1-day for differences)

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/cmo
    """
    inputs=[USEquityPricing.close]
    window_length = 15

    def compute(self, today, assets, out, close):

        # daily differences in close prices
        close_diff = (close - np.roll(close, 1, axis=0))[1:]

        # close differences on up days
        su = np.sum(np.where(close_diff > 0, close_diff, 0), axis=0)

        # absolute value of close differences on down days
        sd = np.abs(np.sum(np.where(close_diff < 0, close_diff, 0), axis=0))

        # CMO
        out[:] = 100 * (su - sd) / (su + sd)
class CMO5D(CustomFactor):
    """
    Chande Momentum Oscillator

    Momentum indicator. Descriptor of overought/oversold conditions

    **Default Inputs:** USEquityPricing.close

    **Default Window Length:** 15 (14 + 1-day for differences)

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/cmo
    """
    inputs=[USEquityPricing.close]
    window_length = 5

    def compute(self, today, assets, out, close):

        # daily differences in close prices
        close_diff = (close - np.roll(close, 1, axis=0))[1:]

        # close differences on up days
        su = np.sum(np.where(close_diff > 0, close_diff, 0), axis=0)

        # absolute value of close differences on down days
        sd = np.abs(np.sum(np.where(close_diff < 0, close_diff, 0), axis=0))

        # CMO
        out[:] = 100 * (su - sd) / (su + sd)
class CMO2D(CustomFactor):
    """
    Chande Momentum Oscillator

    Momentum indicator. Descriptor of overought/oversold conditions

    **Default Inputs:** USEquityPricing.close

    **Default Window Length:** 15 (14 + 1-day for differences)

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/cmo
    """
    inputs=[USEquityPricing.close]
    window_length = 2

    def compute(self, today, assets, out, close):

        # daily differences in close prices
        close_diff = (close - np.roll(close, 1, axis=0))[1:]

        # close differences on up days
        su = np.sum(np.where(close_diff > 0, close_diff, 0), axis=0)

        # absolute value of close differences on down days
        sd = np.abs(np.sum(np.where(close_diff < 0, close_diff, 0), axis=0))

        # CMO
        out[:] = 100 * (su - sd) / (su + sd)


class CMO22D(CustomFactor):
    """
    Chande Momentum Oscillator

    Momentum indicator. Descriptor of overought/oversold conditions

    **Default Inputs:** USEquityPricing.close

    **Default Window Length:** 15 (14 + 1-day for differences)

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/cmo
    """
    inputs=[USEquityPricing.close]
    window_length = 22

    def compute(self, today, assets, out, close):

        # daily differences in close prices
        close_diff = (close - np.roll(close, 1, axis=0))[1:]

        # close differences on up days
        su = np.sum(np.where(close_diff > 0, close_diff, 0), axis=0)

        # absolute value of close differences on down days
        sd = np.abs(np.sum(np.where(close_diff < 0, close_diff, 0), axis=0))

        # CMO
        out[:] = 100 * (su - sd) / (su + sd)

class DX(CustomFactor):
    """
    Directional Movement Index

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquitypricing.close

    **Default Window Length:** 15

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """        
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 15

    def compute(self, today, assets, out, high, low, close):

        # positive directional index
        plus_di = 100 * np.sum(plus_dm_helper(high, low) / (trange_helper(high, low, close)), axis=0)

        # negative directional index
        minus_di = 100 * np.sum(minus_dm_helper(high, low) / (trange_helper(high, low, close)), axis=0)

        # DX
        out[:] = np.abs(plus_di - minus_di) / (plus_di + minus_di) * 100.

class DX1(CustomFactor):
    """
    Directional Movement Index

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquitypricing.close

    **Default Window Length:** 15

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """        
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 1

    def compute(self, today, assets, out, high, low, close):

        # positive directional index
        plus_di = 100 * np.sum(plus_dm_helper(high, low) / (trange_helper(high, low, close)), axis=0)

        # negative directional index
        minus_di = 100 * np.sum(minus_dm_helper(high, low) / (trange_helper(high, low, close)), axis=0)

        # DX
        out[:] = np.abs(plus_di - minus_di) / (plus_di + minus_di) * 100.
class DX2(CustomFactor):
    """
    Directional Movement Index

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquitypricing.close

    **Default Window Length:** 15

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """        
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 2

    def compute(self, today, assets, out, high, low, close):

        # positive directional index
        plus_di = 100 * np.sum(plus_dm_helper(high, low) / (trange_helper(high, low, close)), axis=0)

        # negative directional index
        minus_di = 100 * np.sum(minus_dm_helper(high, low) / (trange_helper(high, low, close)), axis=0)

        # DX
        out[:] = np.abs(plus_di - minus_di) / (plus_di + minus_di) * 100.

class DX5(CustomFactor):
    """
    Directional Movement Index

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquitypricing.close

    **Default Window Length:** 15

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """        
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 5

    def compute(self, today, assets, out, high, low, close):

        # positive directional index
        plus_di = 100 * np.sum(plus_dm_helper(high, low) / (trange_helper(high, low, close)), axis=0)

        # negative directional index
        minus_di = 100 * np.sum(minus_dm_helper(high, low) / (trange_helper(high, low, close)), axis=0)

        # DX
        out[:] = np.abs(plus_di - minus_di) / (plus_di + minus_di) * 100.
class DX22(CustomFactor):
    """
    Directional Movement Index

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquitypricing.close

    **Default Window Length:** 15

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """        
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 22

    def compute(self, today, assets, out, high, low, close):

        # positive directional index
        plus_di = 100 * np.sum(plus_dm_helper(high, low) / (trange_helper(high, low, close)), axis=0)

        # negative directional index
        minus_di = 100 * np.sum(minus_dm_helper(high, low) / (trange_helper(high, low, close)), axis=0)

        # DX
        out[:] = np.abs(plus_di - minus_di) / (plus_di + minus_di) * 100.


class LINEARREG_SLOPE(CustomFactor):
    """
    Slope of Trendline

    Momentum indicator.

    **Default Inputs:**  USEquitypricing.close

    **Default Window Length:** 14

    http://www.stat.cmu.edu/~cshalizi/mreg/15/lectures/06/lecture-06.pdf
    """        
    inputs=[USEquityPricing.close]
    window_length=14

    # using MLE for speed
    def compute(self, today, assets, out, close):

        # prepare X matrix (x_is - x_bar)
        X = range(self.window_length)
        X_bar = np.nanmean(X)
        X_vector = X - X_bar
        X_matrix = np.tile(X_vector, (len(close.T), 1)).T

        # prepare Y matrix (y_is - y_bar)
        Y_bar = np.nanmean(close, axis=0)
        Y_bars = np.tile(Y_bar, (self.window_length, 1))
        Y_matrix = close - Y_bars

        # prepare variance of X
        X_var = np.nanvar(X)

        # multiply X matrix an Y matrix and sum (dot product)
        # then divide by variance of X
        # this gives the MLE of Beta
        out[:] = (np.sum((X_matrix * Y_matrix), axis=0) / X_var) / (self.window_length)


class LINEARREG_INTERCEPT(CustomFactor):
    """
    Intercept of Trendline

    **Default Inputs:**  USEquitypricing.close

    **Default Window Length:** 14

    http://www.stat.cmu.edu/~cshalizi/mreg/15/lectures/06/lecture-06.pdf
    """
    inputs=[USEquityPricing.close]
    window_length=14

    # using MLE
    def compute(self, today, assets, out, close):

        # prepare X matrix (x_is - x_bar)
        X = range(self.window_length)
        X_bar = np.nanmean(X)
        X_vector = X - X_bar
        X_matrix = np.tile(X_vector, (len(close.T), 1)).T

        # prepare Y vectors (y_is - y_bar)
        Y_bar = np.nanmean(close, axis=0)
        Y_bars = np.tile(Y_bar, (self.window_length, 1))
        Y_matrix = close - Y_bars

        # prepare variance of X
        X_var = np.nanvar(X)

        # multiply X matrix an Y matrix and sum (dot product)
        # then divide by variance of X
        # this gives the MLE of Beta
        betas = (np.sum((X_matrix * Y_matrix), axis=0) / X_var) / (self.window_length)

        # now use to get to MLE of alpha
        out[:] = Y_bar - (betas * X_bar)


class MAX(CustomFactor):
    """
    Maximum value for each column of a dataset

    **Default Inputs:**  None

    **Default Window Length:** None
    """
    def compute(self, today, assets, out, data):
        # get vector of maximums
        out[:] = np.nanmax(data, axis=0)


class MAXINDEX(CustomFactor):
    """
    Index of maximum value for each column of a dataset

    **Default Inputs:**  None

    **Default Window Length:** None
    """
    def compute(self, today, assets, out, data):
        # get vector of indices
        out[:] = np.argmax(data, axis=0)


class MEDPRICE(CustomFactor):
    """
    Mean of a day's high and low prices

    **Default Inputs:**  USEquityPricing.high, USEquityPricing.low

    **Default Window Length:** 1

    http://www.fmlabs.com/reference/default.htm?url=MedianPrices.htm
    """        
    inputs = [USEquityPricing.high, USEquityPricing.low]
    window_length = 1

    def compute(self, today, assets, out, high, low):
        out[:] = (high + low) / 2.

class MEDPRICE_2D(CustomFactor):
    """
    Mean of a day's high and low prices

    **Default Inputs:**  USEquityPricing.high, USEquityPricing.low

    **Default Window Length:** 1

    http://www.fmlabs.com/reference/default.htm?url=MedianPrices.htm
    """        
    inputs = [USEquityPricing.high, USEquityPricing.low]
    window_length = 2

    def compute(self, today, assets, out, high, low):
        out[:] = (high + low) / 2.

class MEDPRICE_5D(CustomFactor):
    """
    Mean of a day's high and low prices

    **Default Inputs:**  USEquityPricing.high, USEquityPricing.low

    **Default Window Length:** 1

    http://www.fmlabs.com/reference/default.htm?url=MedianPrices.htm
    """        
    inputs = [USEquityPricing.high, USEquityPricing.low]
    window_length = 5

    def compute(self, today, assets, out, high, low):
        out[:] = (high + low) / 2.

class MEDPRICE_22D(CustomFactor):
    """
    Mean of a day's high and low prices

    **Default Inputs:**  USEquityPricing.high, USEquityPricing.low

    **Default Window Length:** 1

    http://www.fmlabs.com/reference/default.htm?url=MedianPrices.htm
    """        
    inputs = [USEquityPricing.high, USEquityPricing.low]
    window_length = 22

    def compute(self, today, assets, out, high, low):
        out[:] = (high + low) / 2.


class MFI(CustomFactor):
    """
    Money Flow Index

    Volume Indicator

    **Default Inputs:**  USEquityPricing.high, USEquityPricing.low, USEquityPricing.close, USEquityPricing.volume

    **Default Window Length:** 15 (14 + 1-day for difference in prices)

    http://www.fmlabs.com/reference/default.htm?url=MoneyFlowIndex.htm
    """        

    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close, USEquityPricing.volume]
    window_length = 15

    def compute(self, today, assets, out, high, low, close, vol):

        # calculate typical price
        typical_price = (high + low + close) / 3.

        # calculate money flow of typical price
        money_flow = typical_price * vol

        # get differences in daily typical prices
        tprice_diff = (typical_price - np.roll(typical_price, 1, axis=0))[1:]

        # create masked arrays for positive and negative money flow
        pos_money_flow = np.ma.masked_array(money_flow[1:], tprice_diff < 0, fill_value = 0.)
        neg_money_flow = np.ma.masked_array(money_flow[1:], tprice_diff > 0, fill_value = 0.)

        # calculate money ratio
        money_ratio = np.sum(pos_money_flow, axis=0) / np.sum(neg_money_flow, axis=0)

        # MFI
        out[:] = 100. - (100. / (1. + money_ratio))
class MFI1(CustomFactor):
    """
    Money Flow Index

    Volume Indicator

    **Default Inputs:**  USEquityPricing.high, USEquityPricing.low, USEquityPricing.close, USEquityPricing.volume

    **Default Window Length:** 15 (14 + 1-day for difference in prices)

    http://www.fmlabs.com/reference/default.htm?url=MoneyFlowIndex.htm
    """        

    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close, USEquityPricing.volume]
    window_length = 1

    def compute(self, today, assets, out, high, low, close, vol):

        # calculate typical price
        typical_price = (high + low + close) / 3.

        # calculate money flow of typical price
        money_flow = typical_price * vol

        # get differences in daily typical prices
        tprice_diff = (typical_price - np.roll(typical_price, 1, axis=0))[1:]

        # create masked arrays for positive and negative money flow
        pos_money_flow = np.ma.masked_array(money_flow[1:], tprice_diff < 0, fill_value = 0.)
        neg_money_flow = np.ma.masked_array(money_flow[1:], tprice_diff > 0, fill_value = 0.)

        # calculate money ratio
        money_ratio = np.sum(pos_money_flow, axis=0) / np.sum(neg_money_flow, axis=0)

        # MFI
        out[:] = 100. - (100. / (1. + money_ratio))
class MFI2(CustomFactor):
    """
    Money Flow Index

    Volume Indicator

    **Default Inputs:**  USEquityPricing.high, USEquityPricing.low, USEquityPricing.close, USEquityPricing.volume

    **Default Window Length:** 15 (14 + 1-day for difference in prices)

    http://www.fmlabs.com/reference/default.htm?url=MoneyFlowIndex.htm
    """        

    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close, USEquityPricing.volume]
    window_length = 2

    def compute(self, today, assets, out, high, low, close, vol):

        # calculate typical price
        typical_price = (high + low + close) / 3.

        # calculate money flow of typical price
        money_flow = typical_price * vol

        # get differences in daily typical prices
        tprice_diff = (typical_price - np.roll(typical_price, 1, axis=0))[1:]

        # create masked arrays for positive and negative money flow
        pos_money_flow = np.ma.masked_array(money_flow[1:], tprice_diff < 0, fill_value = 0.)
        neg_money_flow = np.ma.masked_array(money_flow[1:], tprice_diff > 0, fill_value = 0.)

        # calculate money ratio
        money_ratio = np.sum(pos_money_flow, axis=0) / np.sum(neg_money_flow, axis=0)

        # MFI
        out[:] = 100. - (100. / (1. + money_ratio))
class MFI5(CustomFactor):
    """
    Money Flow Index

    Volume Indicator

    **Default Inputs:**  USEquityPricing.high, USEquityPricing.low, USEquityPricing.close, USEquityPricing.volume

    **Default Window Length:** 15 (14 + 1-day for difference in prices)

    http://www.fmlabs.com/reference/default.htm?url=MoneyFlowIndex.htm
    """        

    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close, USEquityPricing.volume]
    window_length = 5

    def compute(self, today, assets, out, high, low, close, vol):

        # calculate typical price
        typical_price = (high + low + close) / 3.

        # calculate money flow of typical price
        money_flow = typical_price * vol

        # get differences in daily typical prices
        tprice_diff = (typical_price - np.roll(typical_price, 1, axis=0))[1:]

        # create masked arrays for positive and negative money flow
        pos_money_flow = np.ma.masked_array(money_flow[1:], tprice_diff < 0, fill_value = 0.)
        neg_money_flow = np.ma.masked_array(money_flow[1:], tprice_diff > 0, fill_value = 0.)

        # calculate money ratio
        money_ratio = np.sum(pos_money_flow, axis=0) / np.sum(neg_money_flow, axis=0)

        # MFI
        out[:] = 100. - (100. / (1. + money_ratio))
class MFI22(CustomFactor):
    """
    Money Flow Index

    Volume Indicator

    **Default Inputs:**  USEquityPricing.high, USEquityPricing.low, USEquityPricing.close, USEquityPricing.volume

    **Default Window Length:** 15 (14 + 1-day for difference in prices)

    http://www.fmlabs.com/reference/default.htm?url=MoneyFlowIndex.htm
    """        

    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close, USEquityPricing.volume]
    window_length = 22

    def compute(self, today, assets, out, high, low, close, vol):

        # calculate typical price
        typical_price = (high + low + close) / 3.

        # calculate money flow of typical price
        money_flow = typical_price * vol

        # get differences in daily typical prices
        tprice_diff = (typical_price - np.roll(typical_price, 1, axis=0))[1:]

        # create masked arrays for positive and negative money flow
        pos_money_flow = np.ma.masked_array(money_flow[1:], tprice_diff < 0, fill_value = 0.)
        neg_money_flow = np.ma.masked_array(money_flow[1:], tprice_diff > 0, fill_value = 0.)

        # calculate money ratio
        money_ratio = np.sum(pos_money_flow, axis=0) / np.sum(neg_money_flow, axis=0)

        # MFI
        out[:] = 100. - (100. / (1. + money_ratio))



class MIDPOINT(CustomFactor):
    """
    Average of maximum and minimum column values in a dataset

    **Default Inputs:**  None

    **Default Window Length:** None
    """
    def compute(self, today, assets, out, data):
        out[:] = (np.nanmax(data, axis=0) + np.nanmin(data, axis=0)) / 2.


class MIN(CustomFactor):
    """
    Minimum column values in a dataset

    **Default Inputs:**  None

    **Default Window Length:** None
    """
    def compute(self, today, assets, out, data):
        out[:] = np.nanmin(data, axis=0)


class MININDEX(CustomFactor):
    """
    Index of minimum column values in a dataset

    **Default Inputs:**  None

    **Default Window Length:** None
    """
    def compute(self, today, assets, out, data):
        out[:] = np.argmin(data, axis=0)


class MINUS_DI(CustomFactor):
    """
    Negative directional indicator

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquityPricing.close

    **Default Window Length:** 15

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """    

    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 15

    def compute(self, today, assets, out, high, low, close):
            out[:] = 100 * np.sum(minus_dm_helper(high, low), axis=0) / np.sum(trange_helper(high, low, close), axis=0)


class MINUS_DI_1D(CustomFactor):
    """
    Negative directional indicator

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquityPricing.close

    **Default Window Length:** 15

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """    

    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 1

    def compute(self, today, assets, out, high, low, close):
            out[:] = 100 * np.sum(minus_dm_helper(high, low), axis=0) / np.sum(trange_helper(high, low, close), axis=0)



class MINUS_DI_2D(CustomFactor):
    """
    Negative directional indicator

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquityPricing.close

    **Default Window Length:** 15

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """    

    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 2

    def compute(self, today, assets, out, high, low, close):
            out[:] = 100 * np.sum(minus_dm_helper(high, low), axis=0) / np.sum(trange_helper(high, low, close), axis=0)



class MINUS_DI_5D(CustomFactor):
    """
    Negative directional indicator

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquityPricing.close

    **Default Window Length:** 15

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """    

    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 5

    def compute(self, today, assets, out, high, low, close):
            out[:] = 100 * np.sum(minus_dm_helper(high, low), axis=0) / np.sum(trange_helper(high, low, close), axis=0)




class MINUS_DI_22D(CustomFactor):
    """
    Negative directional indicator

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquityPricing.close

    **Default Window Length:** 15

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """    

    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 22

    def compute(self, today, assets, out, high, low, close):
            out[:] = 100 * np.sum(minus_dm_helper(high, low), axis=0) / np.sum(trange_helper(high, low, close), axis=0)







class MINUS_DM(CustomFactor):
    """
    Negative directional movement

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low

    **Default Window Length:** 15

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """    

    inputs = [USEquityPricing.high, USEquityPricing.low]
    window_length = 15

    def compute(self, today, assets, out, high, low):
            out[:] = np.sum(minus_dm_helper(high, low), axis=0)




class MINUS_DM_1D(CustomFactor):
    """
    Negative directional movement

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low

    **Default Window Length:** 15

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """    

    inputs = [USEquityPricing.high, USEquityPricing.low]
    window_length = 15

    def compute(self, today, assets, out, high, low):
            out[:] = np.sum(minus_dm_helper(high, low), axis=0) 



class MINUS_DM_2D(CustomFactor):
    """
    Negative directional movement

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low

    **Default Window Length:** 15

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """    

    inputs = [USEquityPricing.high, USEquityPricing.low]
    window_length = 15

    def compute(self, today, assets, out, high, low):
            out[:] = np.sum(minus_dm_helper(high, low), axis=0)


class MINUS_DM_5D(CustomFactor):
    """
    Negative directional movement

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low

    **Default Window Length:** 15

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """    

    inputs = [USEquityPricing.high, USEquityPricing.low]
    window_length = 15

    def compute(self, today, assets, out, high, low):
            out[:] = np.sum(minus_dm_helper(high, low), axis=0)



class MINUS_DM_22D(CustomFactor):
    """
    Negative directional movement

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low

    **Default Window Length:** 15

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """    

    inputs = [USEquityPricing.high, USEquityPricing.low]
    window_length = 15

    def compute(self, today, assets, out, high, low):
            out[:] = np.sum(minus_dm_helper(high, low), axis=0)



class PLUS_DI(CustomFactor):
    """
    Positive directional indicator

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquityPricing.close

    **Default Window Length:** 15

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """    
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 15

    def compute(self, today, assets, out, high, low, close):
            out[:] = 100 * np.sum(plus_dm_helper(high, low), axis=0) / np.sum(trange_helper(high, low, close), axis=0)


class PLUS_DI1(CustomFactor):
    """
    Positive directional indicator

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquityPricing.close

    **Default Window Length:** 15

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """    
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 1

    def compute(self, today, assets, out, high, low, close):
            out[:] = 100 * np.sum(plus_dm_helper(high, low), axis=0) / np.sum(trange_helper(high, low, close), axis=0)
class PLUS_DI2(CustomFactor):
    """
    Positive directional indicator

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquityPricing.close

    **Default Window Length:** 15

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """    
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 2

    def compute(self, today, assets, out, high, low, close):
            out[:] = 100 * np.sum(plus_dm_helper(high, low), axis=0) / np.sum(trange_helper(high, low, close), axis=0)
class PLUS_DI5(CustomFactor):
    """
    Positive directional indicator

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquityPricing.close

    **Default Window Length:** 15

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """    
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 5

    def compute(self, today, assets, out, high, low, close):
            out[:] = 100 * np.sum(plus_dm_helper(high, low), axis=0) / np.sum(trange_helper(high, low, close), axis=0)
class PLUS_DI22(CustomFactor):
    """
    Positive directional indicator

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low, USEquityPricing.close

    **Default Window Length:** 15

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """    
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 22

    def compute(self, today, assets, out, high, low, close):
            out[:] = 100 * np.sum(plus_dm_helper(high, low), axis=0) / np.sum(trange_helper(high, low, close), axis=0)



class PLUS_DM(CustomFactor):
    """
    Positive directional movement

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low

    **Default Window Length:** 15

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """    
    inputs = [USEquityPricing.high, USEquityPricing.low]
    window_length = 15

    def compute(self, today, assets, out, high, low):
            out[:] = np.sum(plus_dm_helper(high, low), axis=0)
class PLUS_DM1(CustomFactor):
    """
    Positive directional movement

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low

    **Default Window Length:** 15

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """    
    inputs = [USEquityPricing.high, USEquityPricing.low]
    window_length = 1

    def compute(self, today, assets, out, high, low):
            out[:] = np.sum(plus_dm_helper(high, low), axis=0)
class PLUS_DM2(CustomFactor):
    """
    Positive directional movement

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low

    **Default Window Length:** 15

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """    
    inputs = [USEquityPricing.high, USEquityPricing.low]
    window_length = 2

    def compute(self, today, assets, out, high, low):
            out[:] = np.sum(plus_dm_helper(high, low), axis=0)
class PLUS_DM5(CustomFactor):
    """
    Positive directional movement

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low

    **Default Window Length:** 15

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """    
    inputs = [USEquityPricing.high, USEquityPricing.low]
    window_length = 5

    def compute(self, today, assets, out, high, low):
            out[:] = np.sum(plus_dm_helper(high, low), axis=0)
class PLUS_DM22(CustomFactor):
    """
    Positive directional movement

    Momentum indicator

    **Default Inputs:** USEquityPricing.high, USEquityPricing.low

    **Default Window Length:** 15

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/DMI
    """    
    inputs = [USEquityPricing.high, USEquityPricing.low]
    window_length = 22

    def compute(self, today, assets, out, high, low):
            out[:] = np.sum(plus_dm_helper(high, low), axis=0)


def PPO(fast_period=12, slow_period=26):
    """
    Function to produce CustomFactor of Percentage Price Oscillator
    Called in same way as a normal class, but used in order to give variable
    fast- and slow- periods

    Parameters
    ----------
    fast_period : int > 0
        shorter period moving average 
    slow_period : int > 0 (> fast_period)
        longer period moving average

    Returns
    -------
    zipline.CustomFactor : Percentage Price Oscillator factor

    **Default Inputs:**  12, 26

    http://www.investopedia.com/terms/p/ppo.asp
    """  
    class PPO_(CustomFactor):

        inputs=[USEquityPricing.close]
        window_length = slow_period

        def compute(self, today, assets, out, close):
            slowMA = np.mean(close, axis=0)
            fastMA = np.mean(close[-fast_period:], axis=0)
            out[:] = ((fastMA - slowMA) / slowMA) * 100.

    return PPO_()
def PPO8_13(fast_period=8, slow_period=13):
    """
    Function to produce CustomFactor of Percentage Price Oscillator
    Called in same way as a normal class, but used in order to give variable
    fast- and slow- periods

    Parameters
    ----------
    fast_period : int > 0
        shorter period moving average 
    slow_period : int > 0 (> fast_period)
        longer period moving average

    Returns
    -------
    zipline.CustomFactor : Percentage Price Oscillator factor

    **Default Inputs:**  12, 26

    http://www.investopedia.com/terms/p/ppo.asp
    """  
    class PPO_(CustomFactor):

        inputs=[USEquityPricing.close]
        window_length = slow_period

        def compute(self, today, assets, out, close):
            slowMA = np.mean(close, axis=0)
            fastMA = np.mean(close[-fast_period:], axis=0)
            out[:] = ((fastMA - slowMA) / slowMA) * 100.

    return PPO_()
def PPO1_3(fast_period=1, slow_period=3):
    """
    Function to produce CustomFactor of Percentage Price Oscillator
    Called in same way as a normal class, but used in order to give variable
    fast- and slow- periods

    Parameters
    ----------
    fast_period : int > 0
        shorter period moving average 
    slow_period : int > 0 (> fast_period)
        longer period moving average

    Returns
    -------
    zipline.CustomFactor : Percentage Price Oscillator factor

    **Default Inputs:**  12, 26

    http://www.investopedia.com/terms/p/ppo.asp
    """  
    class PPO_(CustomFactor):

        inputs=[USEquityPricing.close]
        window_length = slow_period

        def compute(self, today, assets, out, close):
            slowMA = np.mean(close, axis=0)
            fastMA = np.mean(close[-fast_period:], axis=0)
            out[:] = ((fastMA - slowMA) / slowMA) * 100.

    return PPO_()
def PPO24_50(fast_period=24, slow_period=50):
    """
    Function to produce CustomFactor of Percentage Price Oscillator
    Called in same way as a normal class, but used in order to give variable
    fast- and slow- periods

    Parameters
    ----------
    fast_period : int > 0
        shorter period moving average 
    slow_period : int > 0 (> fast_period)
        longer period moving average

    Returns
    -------
    zipline.CustomFactor : Percentage Price Oscillator factor

    **Default Inputs:**  12, 26

    http://www.investopedia.com/terms/p/ppo.asp
    """  
    class PPO_(CustomFactor):

        inputs=[USEquityPricing.close]
        window_length = slow_period

        def compute(self, today, assets, out, close):
            slowMA = np.mean(close, axis=0)
            fastMA = np.mean(close[-fast_period:], axis=0)
            out[:] = ((fastMA - slowMA) / slowMA) * 100.

    return PPO_()



class STDDEV(CustomFactor):
    """
    Standard Deviations of columns in a dataset

    **Default Inputs:**  None

    **Default Window Length:** None
    """
    def compute(self, today, assets, out, data):
        out[:] = np.nanstd(data, axis=0)


class TRANGE(CustomFactor):
    """
    True Range 

    **Default Inputs:**  USEquityPricing.high, USEquityPricing.low, USEquityPricing.close

    **Default Window Length:** 2

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/atr
    """    
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 2

    def compute(self, today, assets, out, high, low, close):
        out[:] = np.nanmax([(high[-1] - close[0]), (close[0] - low[-1]), (high[-1] - low[-1])], axis=0)


class TRANGE_1D(CustomFactor):
    """
    True Range 

    **Default Inputs:**  USEquityPricing.high, USEquityPricing.low, USEquityPricing.close

    **Default Window Length:** 2

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/atr
    """    
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 2

    def compute(self, today, assets, out, high, low, close):
        out[:] = np.nanmax([(high[-1] - close[0]), (close[0] - low[-1]), (high[-1] - low[-1])], axis=0)

class TRANGE_5D(CustomFactor):
    """
    True Range 

    **Default Inputs:**  USEquityPricing.high, USEquityPricing.low, USEquityPricing.close

    **Default Window Length:** 2

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/atr
    """    
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 5

    def compute(self, today, assets, out, high, low, close):
        out[:] = np.nanmax([(high[-1] - close[0]), (close[0] - low[-1]), (high[-1] - low[-1])], axis=0)

class TRANGE_22D(CustomFactor):
    """
    True Range 

    **Default Inputs:**  USEquityPricing.high, USEquityPricing.low, USEquityPricing.close

    **Default Window Length:** 2

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/atr
    """    
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 22

    def compute(self, today, assets, out, high, low, close):
        out[:] = np.nanmax([(high[-1] - close[0]), (close[0] - low[-1]), (high[-1] - low[-1])], axis=0)


class TYPPRICE(CustomFactor):
    """
    Typical Price 

    **Default Inputs:**  USEquityPricing.high, USEquityPricing.low, USEquityPricing.close

    **Default Window Length:** 1

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/typical-price
    """    
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 1

    def compute(self, today, assets, out, high, low, close):
        out[:] = (high + low + close) / 3.


class TYPPRICE_2D(CustomFactor):
    """
    Typical Price 

    **Default Inputs:**  USEquityPricing.high, USEquityPricing.low, USEquityPricing.close

    **Default Window Length:** 1

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/typical-price
    """    
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 2

    def compute(self, today, assets, out, high, low, close):
        out[:] = (high + low + close) / 3.

class TYPPRICE_5D(CustomFactor):
    """
    Typical Price 

    **Default Inputs:**  USEquityPricing.high, USEquityPricing.low, USEquityPricing.close

    **Default Window Length:** 1

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/typical-price
    """    
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 5

    def compute(self, today, assets, out, high, low, close):
        out[:] = (high + low + close) / 3.

class TYPPRICE_22D(CustomFactor):
    """
    Typical Price 

    **Default Inputs:**  USEquityPricing.high, USEquityPricing.low, USEquityPricing.close

    **Default Window Length:** 1

    https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/typical-price
    """    
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 22

    def compute(self, today, assets, out, high, low, close):
        out[:] = (high + low + close) / 3.


class VAR(CustomFactor):
    """
    Variances of columns in a dataset

    **Default Inputs:**  None

    **Default Window Length:** None
    """
    def compute(self, today, assets, out, data):
        out[:] = np.nanvar(data, axis=0)



class WILLR(CustomFactor):
    """
    Williams %R

    **Default Inputs:**  USEquityPricing.high, USEquityPricing.low, USEquityPricing.close

    **Default Window Length:** 14

    http://www.fmlabs.com/reference/default.htm?url=WilliamsR.htm
    """            
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 14

    def compute(self, today, assets, out, high, low, close):
        out[:] = (np.nanmax(high, axis=0) - close[-1]) / (np.nanmax(high, axis=0) - np.nanmin(low, axis=0)) * -100.


class WILLR1(CustomFactor):
    """
    Williams %R

    **Default Inputs:**  USEquityPricing.high, USEquityPricing.low, USEquityPricing.close

    **Default Window Length:** 14

    http://www.fmlabs.com/reference/default.htm?url=WilliamsR.htm
    """            
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 1

    def compute(self, today, assets, out, high, low, close):
        out[:] = (np.nanmax(high, axis=0) - close[-1]) / (np.nanmax(high, axis=0) - np.nanmin(low, axis=0)) * -100.
class WILLR2(CustomFactor):
    """
    Williams %R

    **Default Inputs:**  USEquityPricing.high, USEquityPricing.low, USEquityPricing.close

    **Default Window Length:** 14

    http://www.fmlabs.com/reference/default.htm?url=WilliamsR.htm
    """            
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 2

    def compute(self, today, assets, out, high, low, close):
        out[:] = (np.nanmax(high, axis=0) - close[-1]) / (np.nanmax(high, axis=0) - np.nanmin(low, axis=0)) * -100.
class WILLR5(CustomFactor):
    """
    Williams %R

    **Default Inputs:**  USEquityPricing.high, USEquityPricing.low, USEquityPricing.close

    **Default Window Length:** 14

    http://www.fmlabs.com/reference/default.htm?url=WilliamsR.htm
    """            
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 5

    def compute(self, today, assets, out, high, low, close):
        out[:] = (np.nanmax(high, axis=0) - close[-1]) / (np.nanmax(high, axis=0) - np.nanmin(low, axis=0)) * -100.
class WILLR22(CustomFactor):
    """
    Williams %R

    **Default Inputs:**  USEquityPricing.high, USEquityPricing.low, USEquityPricing.close

    **Default Window Length:** 14

    http://www.fmlabs.com/reference/default.htm?url=WilliamsR.htm
    """            
    inputs = [USEquityPricing.high, USEquityPricing.low, USEquityPricing.close]
    window_length = 22

    def compute(self, today, assets, out, high, low, close):
        out[:] = (np.nanmax(high, axis=0) - close[-1]) / (np.nanmax(high, axis=0) - np.nanmin(low, axis=0)) * -100.





class RSI_10d(CustomFactor):
    inputs = [USEquityPricing.close]
    window_length = 60

    def compute(self, today, assets, out, close):

        sig_lines = []

        for col in close.T:
            # get signal line only
            try:
                signal_line = talib.RSI(col, timeperiod = 10)
                sig_lines.append(signal_line[-1])
            # if error calculating, return NaN
            except:
                sig_lines.append(np.nan)
        out[:] = sig_lines

# THESE ARE MY CUSTOM TALIB FACTORS

class Moneyflow_Volume_5d(CustomFactor):
    inputs = [USEquityPricing.close, USEquityPricing.volume]
    window_length = 5

    def compute(self, today, assets, out, close, volume):

        mfvs = []

        for col_c, col_v in zip(close.T, volume.T):

            # denominator
            denominator = np.dot(col_c, col_v)

            # numerator
            numerator = 0.
            for n, price in enumerate(col_c.tolist()):
                if price > col_c[n - 1]:
                    numerator += price * col_v[n]
                else:
                    numerator -= price * col_v[n]

            mfvs.append(numerator / denominator)
        out[:] = mfvs  


class Moneyflow_Volume_1d(CustomFactor):
    inputs = [USEquityPricing.close, USEquityPricing.volume]
    window_length = 1

    def compute(self, today, assets, out, close, volume):

        mfvs = []

        for col_c, col_v in zip(close.T, volume.T):

            # denominator
            denominator = np.dot(col_c, col_v)

            # numerator
            numerator = 0.
            for n, price in enumerate(col_c.tolist()):
                if price > col_c[n - 1]:
                    numerator += price * col_v[n]
                else:
                    numerator -= price * col_v[n]

            mfvs.append(numerator / denominator)
        out[:] = mfvs  


class Moneyflow_Volume_2d(CustomFactor):
    inputs = [USEquityPricing.close, USEquityPricing.volume]
    window_length = 2

    def compute(self, today, assets, out, close, volume):

        mfvs = []

        for col_c, col_v in zip(close.T, volume.T):

            # denominator
            denominator = np.dot(col_c, col_v)

            # numerator
            numerator = 0.
            for n, price in enumerate(col_c.tolist()):
                if price > col_c[n - 1]:
                    numerator += price * col_v[n]
                else:
                    numerator -= price * col_v[n]

            mfvs.append(numerator / denominator)
        out[:] = mfvs  


class Moneyflow_Volume_22d(CustomFactor):
    inputs = [USEquityPricing.close, USEquityPricing.volume]
    window_length = 22

    def compute(self, today, assets, out, close, volume):

        mfvs = []

        for col_c, col_v in zip(close.T, volume.T):

            # denominator
            denominator = np.dot(col_c, col_v)

            # numerator
            numerator = 0.
            for n, price in enumerate(col_c.tolist()):
                if price > col_c[n - 1]:
                    numerator += price * col_v[n]
                else:
                    numerator -= price * col_v[n]

            mfvs.append(numerator / denominator)
        out[:] = mfvs  


def Net_Income_Margin():
    return or_.net_margin.latest           

def Operating_Cashflows_To_Assets():
    return (cfs.operating_cash_flow.latest * 4.) / \
        bs.total_assets.latest

def Price_Momentum_3M():
    return Returns(window_length=63)


class Price_Oscillator(CustomFactor):
    inputs = [USEquityPricing.close]
    window_length = 252

    def compute(self, today, assets, out, close):
        four_week_period = close[-20:]
        out[:] = (np.nanmean(four_week_period, axis=0) /
                  np.nanmean(close, axis=0)) - 1.

class Price_Oscillator1(CustomFactor):
    inputs = [USEquityPricing.close]
    window_length = 252

    def compute(self, today, assets, out, close):
        four_week_period = close[-1:]
        out[:] = (np.nanmean(four_week_period, axis=0) /
                  np.nanmean(close, axis=0)) - 1.
class Price_Oscillator2(CustomFactor):
    inputs = [USEquityPricing.close]
    window_length = 252

    def compute(self, today, assets, out, close):
        four_week_period = close[-2:]
        out[:] = (np.nanmean(four_week_period, axis=0) /
                  np.nanmean(close, axis=0)) - 1.
class Price_Oscillator5(CustomFactor):
    inputs = [USEquityPricing.close]
    window_length = 252

    def compute(self, today, assets, out, close):
        four_week_period = close[-5:]
        out[:] = (np.nanmean(four_week_period, axis=0) /
                  np.nanmean(close, axis=0)) - 1.
class Price_Oscillator22(CustomFactor):
    inputs = [USEquityPricing.close]
    window_length = 252

    def compute(self, today, assets, out, close):
        four_week_period = close[-22:]
        out[:] = (np.nanmean(four_week_period, axis=0) /
                  np.nanmean(close, axis=0)) - 1.


#mamalol3
def Returns_39W():
    return Returns(window_length=215)


def Returns_39W_190():
    return Returns(window_length=190)

def Returns_39W_160():
    return Returns(window_length=160)



def Returns_39W_100():
    return Returns(window_length=100)


def Returns_39W_50():
    return Returns(window_length=50)



def Returns_39W_25():
    return Returns(window_length=25)

class Trendline(CustomFactor):
    inputs = [USEquityPricing.close]
    window_length = 252

    # using MLE for speed
    def compute(self, today, assets, out, close):

        # prepare X matrix (x_is - x_bar)
        X = range(self.window_length)
        X_bar = np.nanmean(X)
        X_vector = X - X_bar
        X_matrix = np.tile(X_vector, (len(close.T), 1)).T

        # prepare Y matrix (y_is - y_bar)
        Y_bar = np.nanmean(close, axis=0)
        Y_bars = np.tile(Y_bar, (self.window_length, 1))
        Y_matrix = close - Y_bars

        # prepare variance of X
        X_var = np.nanvar(X)

        # multiply X matrix an Y matrix and sum (dot product)
        # then divide by variance of X
        # this gives the MLE of Beta
        out[:] = (np.sum((X_matrix * Y_matrix), axis=0) / X_var) / \
            (self.window_length)
class Trendline25(CustomFactor):
    inputs = [USEquityPricing.close]
    window_length = 25

    # using MLE for speed
    def compute(self, today, assets, out, close):

        # prepare X matrix (x_is - x_bar)
        X = range(self.window_length)
        X_bar = np.nanmean(X)
        X_vector = X - X_bar
        X_matrix = np.tile(X_vector, (len(close.T), 1)).T

        # prepare Y matrix (y_is - y_bar)
        Y_bar = np.nanmean(close, axis=0)
        Y_bars = np.tile(Y_bar, (self.window_length, 1))
        Y_matrix = close - Y_bars

        # prepare variance of X
        X_var = np.nanvar(X)

        # multiply X matrix an Y matrix and sum (dot product)
        # then divide by variance of X
        # this gives the MLE of Beta
        out[:] = (np.sum((X_matrix * Y_matrix), axis=0) / X_var) / \
            (self.window_length)
class Trendline50(CustomFactor):
    inputs = [USEquityPricing.close]
    window_length = 252

    # using MLE for speed
    def compute(self, today, assets, out, close):

        # prepare X matrix (x_is - x_bar)
        X = range(self.window_length)
        X_bar = np.nanmean(X)
        X_vector = X - X_bar
        X_matrix = np.tile(X_vector, (len(close.T), 1)).T

        # prepare Y matrix (y_is - y_bar)
        Y_bar = np.nanmean(close, axis=0)
        Y_bars = np.tile(Y_bar, (self.window_length, 1))
        Y_matrix = close - Y_bars

        # prepare variance of X
        X_var = np.nanvar(X)

        # multiply X matrix an Y matrix and sum (dot product)
        # then divide by variance of X
        # this gives the MLE of Beta
        out[:] = (np.sum((X_matrix * Y_matrix), axis=0) / X_var) / \
            (self.window_length)
class Trendline100(CustomFactor):
    inputs = [USEquityPricing.close]
    window_length = 252

    # using MLE for speed
    def compute(self, today, assets, out, close):

        # prepare X matrix (x_is - x_bar)
        X = range(self.window_length)
        X_bar = np.nanmean(X)
        X_vector = X - X_bar
        X_matrix = np.tile(X_vector, (len(close.T), 1)).T

        # prepare Y matrix (y_is - y_bar)
        Y_bar = np.nanmean(close, axis=0)
        Y_bars = np.tile(Y_bar, (self.window_length, 1))
        Y_matrix = close - Y_bars

        # prepare variance of X
        X_var = np.nanvar(X)

        # multiply X matrix an Y matrix and sum (dot product)
        # then divide by variance of X
        # this gives the MLE of Beta
        out[:] = (np.sum((X_matrix * Y_matrix), axis=0) / X_var) / \
            (self.window_length)
class Trendline150(CustomFactor):
    inputs = [USEquityPricing.close]
    window_length = 252

    # using MLE for speed
    def compute(self, today, assets, out, close):

        # prepare X matrix (x_is - x_bar)
        X = range(self.window_length)
        X_bar = np.nanmean(X)
        X_vector = X - X_bar
        X_matrix = np.tile(X_vector, (len(close.T), 1)).T

        # prepare Y matrix (y_is - y_bar)
        Y_bar = np.nanmean(close, axis=0)
        Y_bars = np.tile(Y_bar, (self.window_length, 1))
        Y_matrix = close - Y_bars

        # prepare variance of X
        X_var = np.nanvar(X)

        # multiply X matrix an Y matrix and sum (dot product)
        # then divide by variance of X
        # this gives the MLE of Beta
        out[:] = (np.sum((X_matrix * Y_matrix), axis=0) / X_var) / \
            (self.window_length)

class Vol_3M(CustomFactor):
    inputs = [Returns(window_length=2)]
    window_length = 63

    def compute(self, today, assets, out, rets):
        out[:] = np.nanstd(rets, axis=0)

class Vol_1D(CustomFactor):
    inputs = [Returns(window_length=2)]
    window_length = 1

    def compute(self, today, assets, out, rets):
        out[:] = np.nanstd(rets, axis=0)

class Vol_2D(CustomFactor):
    inputs = [Returns(window_length=2)]
    window_length = 2

    def compute(self, today, assets, out, rets):
        out[:] = np.nanstd(rets, axis=0)

class Vol_5D(CustomFactor):
    inputs = [Returns(window_length=2)]
    window_length = 5

    def compute(self, today, assets, out, rets):
        out[:] = np.nanstd(rets, axis=0)

class Vol_22D(CustomFactor):
    inputs = [Returns(window_length=2)]
    window_length = 22

    def compute(self, today, assets, out, rets):
        out[:] = np.nanstd(rets, axis=0)

def Working_Capital_To_Assets():
    return bs.working_capital.latest / bs.total_assets.latest

# NOTE BOOK FACTORS HERE








#HELLOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO

# Factor of yesterday's close price.
# yesterday_close = USEquityPricing.close.latest

# sma_20 = Factors.SimpleMovingAverage(inputs=[USEquityPricing.close], window_length=20, mask=base_universe)  
# sma_200 = Factors.SimpleMovingAverage(inputs=[USEquityPricing.close], window_length=200, mask=base_universe)

# # STOP LOSS
# stop_long = yesterday_close - (yesterday_close*0.05) # jodi 5% kome jay tahole beche dibo
# stop_short = yesterday_close + (yesterday_close*0.025) # jodi 5% kome jay tahole beche dibo

#HELLOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO

features = {
    # 'AD': AD,
    'AD_1D': AD_1D,    #used 
    # 'AD_2D': AD_2D,
    # 'AD_5D': AD_5D,
    # 'AD_22D': AD_22D,

    # 'ADX': ADX,

    # 'APO': APO,

    # 'ATR': ATR,
    'ATR2': ATR2,   #used 
    # 'ATR5': ATR5,
    # 'ATR22': ATR22,

    # 'BETA': BETA,        
    # 'BETA_2D': BETA_2D,
    # 'BETA_5D': BETA_5D,
    'BETA_22D': BETA_22D, #used 

    'BOP': BOP,    #used  

    # 'CCI': CCI,
    # 'CCI_1D': CCI_1D,
    # 'CCI_2D': CCI_2D,
    'CCI_5D': CCI_5D,    #used 
    # 'CCI_22D': CCI_22D,

    # 'CMO': CMO,
    'CMO2D': CMO2D, #used
    # 'CMO5D': CMO5D,
    # 'CMO22D': CMO22D,

    # 'DX': DX,
    'DX2': DX2,             #used 
    # 'DX5': DX5,
    # 'DX22': DX22,

    'MEDPRICE': MEDPRICE,    #used 

    # 'MFI': MFI,
    # 'MFI1': MFI1,
    # 'MFI2': MFI2,
    # 'MFI5': MFI5,
    'MFI22': MFI22,        #used 


    # 'MINUS_DI': MINUS_DI,
    # 'MINUS_DI_2D': MINUS_DI_2D,
    # 'MINUS_DI_5D': MINUS_DI_5D,
    # 'MINUS_DI_22D': MINUS_DI_22D,


    # 'MINUS_DM': MINUS_DM,
    # 'MINUS_DM_1D': MINUS_DM_1D,
    # 'MINUS_DM_2D': MINUS_DM_2D,
    # 'MINUS_DM_5D': MINUS_DM_5D,
    # 'MINUS_DM_22D': MINUS_DM_22D,


    # 'PLUS_DI': PLUS_DI,   
    'PLUS_DI2': PLUS_DI2,    #used 
    # 'PLUS_DI5': PLUS_DI5,
    # 'PLUS_DI22': PLUS_DI22,


    # 'PLUS_DM': PLUS_DM,
    # 'PLUS_DM1': PLUS_DM1,
    'PLUS_DM2': PLUS_DM2,         #super USED 
    # 'PLUS_DM5': PLUS_DM5,
    # 'PLUS_DM22': PLUS_DM22,


    'PPO': PPO,          #used
    # 'PPO8_13': PPO8_13,
    # 'PPO1_3': PPO1_3,
    # 'PPO24_50': PPO24_50,

    # 'TRANGE_1D': TRANGE_1D,
    # 'TRANGE': TRANGE,
    'TRANGE_5D': TRANGE_5D, #used 
    # 'TRANGE_22D': TRANGE_22D,

    # 'TYPPRICE': TYPPRICE,

    # 'WILLR': WILLR,
    'WILLR1': WILLR1, #used 
    # 'WILLR2': WILLR2,
    # 'WILLR5': WILLR5,
    # 'WILLR22': WILLR22,


    # 'Asset Growth 3M': Asset_Growth_3M,
    'Asset Growth 2D': Asset_Growth_2D,    #used 
    # 'Asset Growth 5D': Asset_Growth_5D,
    # 'Asset Growth 22D': Asset_Growth_22D,

    'Asset to Equity Ratio': Asset_To_Equity_Ratio, #used

    'Capex to Cashflows': Capex_To_Cashflows,    #used 

    'EBIT to Assets': EBIT_To_Assets,    #used 

    # 'EBITDA Yield': EBITDA_Yield,       

    # 'Earnings Quality': Earnings_Quality,

    'MACD Signal Line': MACD_Signal_10d,    #used 
    # 'MACD Signal Line 1D': MACD_Signal_1d,
    # 'MACD Signal Line 2D': MACD_Signal_2d,
    # 'MACD Signal Line 5D': MACD_Signal_5d,
    # 'MACD Signal Line 22D': MACD_Signal_22d,

    # 'Mean Reversion 1M': Mean_Reversion_1M,
    'Mean Reversion 2D': Mean_Reversion_2D,#used
    # 'Mean Reversion 5D': Mean_Reversion_5D,
    # 'Mean Reversion 6D': Mean_Reversion_6D,

    # 'Moneyflow Volume 5D': Moneyflow_Volume_5d,
    # 'Moneyflow Volume 1D': Moneyflow_Volume_1d,
    # 'Moneyflow Volume 2D': Moneyflow_Volume_2d,
    'Moneyflow Volume 22D': Moneyflow_Volume_22d,    #used 

    # 'Net Income Margin': Net_Income_Margin,    

    'Operating Cashflows to Assets': Operating_Cashflows_To_Assets,    #used 

    'Price Momentum 3M': Price_Momentum_3M, #used

    # 'Price Oscillator': Price_Oscillator,
    'Price Oscillator1': Price_Oscillator1,    #used 
    # 'Price Oscillator2': Price_Oscillator2,
    # 'Price Oscillator5': Price_Oscillator5,
    # 'Price Oscillator22': Price_Oscillator22,

    'Return on Invest Capital': Return_On_Total_Invest_Capital, #used

    # '39 Week Returns': Returns_39W,
    '39 Week Returns100': Returns_39W_100, #used
    # '39 Week Returns50': Returns_39W_50,
    # '39 Week Returns25': Returns_39W_25,
    # '39 Week Returns160': Returns_39W_160,
    # '39 Week Returns190': Returns_39W_190,

    'Trendline': Trendline,   #used 
    # 'Trendline25': Trendline25,
    # 'Trendline50': Trendline50,
    # 'Trendline100': Trendline100,
    # 'Trendline150': Trendline150,

    # 'Vol 3M': Vol_3M,
    # 'Vol 1D': Vol_1D,
    # 'Vol 2D': Vol_2D,
    'Vol 5D': Vol_5D,        #used 
    # 'Vol 22D': Vol_22D,

 
}


def shift_mask_data(features,
                    labels,
                    n_forward_days,
                    lower_percentile,
                    upper_percentile):
    """Align features to the labels ``n_forward_days`` into the future and
    return the discrete, flattened features and masked labels.

    Parameters
    ----------
    features : np.ndarray
        A 3d array of (days, assets, feature).
    labels : np.ndarray
        The labels to predict.
    n_forward_days : int
        How many days into the future are we predicting?
    lower_percentile : float
        The lower percentile in the range [0, 100].
    upper_percentile : float
        The upper percentile in the range [0, 100].

    Returns
    -------
    selected_features : np.ndarray
        The flattened features that are not masked out.
    selected_labels : np.ndarray
        The labels that are not masked out.
    """

    # Slice off rolled elements
    shift_by = n_forward_days + 1
    aligned_features = features[:-shift_by]
    aligned_labels = labels[shift_by:]

    cutoffs = np.nanpercentile(
        aligned_labels,
        [lower_percentile, upper_percentile],
        axis=1,
    )
    discrete_labels = np.select(
        [
            aligned_labels <= cutoffs[0, :, np.newaxis],
            aligned_labels >= cutoffs[1, :, np.newaxis],
        ],
        [-1, 1],
    )

    # flatten the features per day
    flattened_features = aligned_features.reshape(
        -1,
        aligned_features.shape[-1],
    )

    # Drop stocks that did not move much, meaning they are in between
    # ``lower_percentile`` and ``upper_percentile``.
    mask = discrete_labels != 0

    selected_features = flattened_features[mask.ravel()]
    selected_labels = discrete_labels[mask]

    return selected_features, selected_labels


class ML(CustomFactor):
    """
    """
    train_on_weekday = 1

    def __init__(self, *args, **kwargs):
        CustomFactor.__init__(self, *args, **kwargs)

        self._imputer = preprocessing.Imputer()
        self._scaler = preprocessing.MinMaxScaler()
        
        
        # ada_param=  {  'n_estimators': 150 , 'algorithm':'SAMME.R'}
        # svc_param= {'C':1000,'gamma':0.0001, 'kernel':'rbf' }
        # gboost_param ={'learning_rate': 0.1, 'max_depth': 4, 'n_estimators': 300,'min_samples_split': 4 ,'subsample':0.6 ,"min_samples_split": 0.15,"min_samples_leaf": 0.15,"max_features":"sqrt"}
        # logistic_param ={ 'C':.1, 'penalty':'l2',"tol":0.0001}
        logistic_param2 ={'C':1000, 'penalty':'l1', 'random_state':42 }
        rfp= {'bootstrap': True , 'max_depth': 4, 'n_estimators': 100,'min_samples_split': 4  ,"min_samples_split": 0.15,"min_samples_leaf": 0.15,"max_features":"log2"}
        sgdc_p = {'alpha': 1e-4, 'loss': 'hinge', 'penalty': 'elasticnet','n_jobs': -1, 'random_state':42}
        dtc_p=  { "criterion" :'entropy' ,'max_depth': 7,"min_samples_split" : 3}
        #self._classifier =GradientBoostingClassifier()
        #self._classifier = linear_model.SGDClassifier(penalty='elasticnet')
        self._classifier = GaussianNB()
        self._classifier2 = LogisticRegression(**logistic_param2)
        self._classifier3 =  DTC(**dtc_p)
        self._classifier4 = sgdc(** sgdc_p)
        self._trained = False
        #ensemble.AdaBoostClassifier(
        #    random_state=1337,
        #    n_estimators=50,
        #)

    def _compute(self, *args, **kwargs):
        ret = CustomFactor._compute(self, *args, **kwargs)
        return ret

    def _train_model(self, today, returns, inputs):
        log.info('training model for window starting on: {}'.format(today))

        imputer = self._imputer
        scaler = self._scaler
        classifier = self._classifier
        classifier2 = self._classifier2
        classifier3 = self._classifier3
        classifier4 = self._classifier4

        features, labels = shift_mask_data(
            np.dstack(inputs),
            returns,
            n_forward_days=PRED_N_FORWARD_DAYS,
            lower_percentile=30,
            upper_percentile=70,
        )
        features = scaler.fit_transform(imputer.fit_transform(features))

        start = time()
        
        # ffs = f_regression(features, labels )
        # variable = [ ]
        # count=0
        # for i in range(features.shape[1]):
        #     if ffs[0][i] >=30:
        #        variable.append(count)
        #     count= count+1

        # helper.reduced_columns= variable
        # print("/////////////////////////////////")
        # print(helper.reduced_columns)
        # #drop SMA
        # features = features[:, helper.reduced_columns]
        test = SelectKBest(score_func=f_classif , k=25)
        kbestfit = test.fit(features, labels)
        kbestbool=kbestfit.get_support()
        count=0
        kbestchi_feature=[]
        for i in kbestbool:
            if i:
                kbestchi_feature.append(count)
            count=count+1


        helper.reduced_columns=kbestchi_feature
        print("/////////////////////////////////")
        print(helper.reduced_columns)
        #drop SMA
        features = features[:, helper.reduced_columns]
        
        
        
        classifier.fit(features, labels)
        classifier2.fit(features, labels)
        classifier3.fit(features, labels)
        classifier4.fit(features, labels)
        
        log.info('training took {} secs'.format(time() - start))
        self._trained = True

    def _maybe_train_model(self, today, returns, inputs):
        if (today.weekday() == self.train_on_weekday) or not self._trained:
            self._train_model(today, returns, inputs)

    def compute(self, today, assets, out, returns, *inputs):
        # inputs is a list of factors, for example, assume we have 2 alpha
        # signals, 3 stocks, and a lookback of 2 days. Each element in the
        # inputs list will be data of one signal, so len(inputs) == 2. Then
        # each element will contain a 2-D array of shape [time x stocks]. For
        # example:
        # inputs[0]:
        # [[1, 3, 2], # factor 1 rankings of day t-1 for 3 stocks
        #  [3, 2, 1]] # factor 1 rankings of day t for 3 stocks
        # inputs[1]:
        # [[2, 3, 1], # factor 2 rankings of day t-1 for 3 stocks
        #  [1, 2, 3]] # factor 2 rankings of day t for 3 stocks
        self._maybe_train_model(today, returns, inputs)

        # Predict
        # Get most recent factor values (inputs always has the full history)
        last_factor_values = np.vstack([input_[-1] for input_ in inputs]).T
        last_factor_values = self._imputer.transform(last_factor_values)
        last_factor_values = self._scaler.transform(last_factor_values)
        
        
        # last_factor_values = last_factor_values[:, helper.reduced_columns]

        # Predict the probability for each stock going up
        # (column 2 of the output of .predict_proba()) and
        # return it via assignment to out.
        #out[:] = self._classifier.predict_proba(last_factor_values)[:, 1]
        
        

        
        last_factor_values = last_factor_values[:, helper.reduced_columns]
        
        # out2=self._classifier2.predict(last_factor_values)
        # out3=self._classifier3.predict(last_factor_values)
        # out4=self._classifier4.predict(last_factor_values)
        # out3=np.add(out3,out2)

        out1=self._classifier.predict(last_factor_values)
        # out3=np.add(out3,out1)
        # out3= np.add(out4,out3)
        # print("out3")
        # print(type(out3))
        # print(out3)
        out[:] = out1

def make_ml_pipeline(universe, window_length=21, n_forward_days=5):
    pipeline_columns = OrderedDict()

    # ensure that returns is the first input
    pipeline_columns['Returns'] = Returns(
        inputs=(USEquityPricing.open,),
        mask=universe, window_length=n_forward_days + 1,
    )

    #HELLOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO start
    # Factor of yesterday's close price.
        
    # pipeline_columns['RSI'] = RSI() # Thick ase
#     pipeline_columns['VWAP'] = VWAP(window_length=215) # Thick ase
#    pipeline_columns['True_RANGE'] = TrueRange() # Thick ase # ALGO TRADING A CHOLE NAH

    # pipeline_columns['MovingAverageConvergenceDivergenceSignal'] = MovingAverageConvergenceDivergenceSignal() # Thick ase # ALGO TRADING A CHOLE NAH
    # pipeline_columns['MarketCap'] = MarketCap() # Thick ase # ALGO TRADING A CHOLE NAH

#     pipeline_columns['FastStochasticOscillator'] = FastStochasticOscillator() #THick ase
# # #     factor_ranks['BollingerBands'] =BollingerBands(window_length=215, k=2 # Jhamela ase
    # pipeline_columns['AverageDollarVolume'] = AverageDollarVolume(window_length=215) #THick ase # ALGO TRADING A CHOLE NAH
    # pipeline_columns['AnnualizedVolatility'] = AnnualizedVolatility() #THick ase # ALGO TRADING A CHOLE NAH
    
    # pipeline_columns['FastStochasticOscillator'] = FastStochasticOscillator() #THick ase  

    # sma_20 = Factors.SimpleMovingAverage(inputs=[USEquityPricing.close], window_length=20, mask=universe)  
    # sma_200 = Factors.SimpleMovingAverage(inputs=[USEquityPricing.close], window_length=200, mask=universe)

    
    
    # pipeline_columns['long'] = (sma_20 >= sma_200)  
    # #pipeline_colunms['long'].test_column.astype(int)
    
    # pipeline_columns['short'] = (sma_20 < sma_200) 

    
    # rank all the factors and put them after returns
    pipeline_columns.update({
        name: f().rank(mask=universe) for name, f in features.items()
    })

    # Create our ML pipeline factor. The window_length will control how much
    # lookback the passed in data will have.
    pipeline_columns['ML'] = ML(
        inputs=pipeline_columns.values(),
        window_length=window_length + 1,
        mask=universe,
    )

    pipeline_columns['Sector'] = Sector()
    return Pipeline(screen=universe, columns=pipeline_columns)

def initialize(context):
    """
    Called once at the start of the algorithm.
    """
    set_slippage(slippage.FixedSlippage(spread=0.00))
    set_commission(commission.PerShare(cost=0, min_trade_cost=0))
    schedule_function(
        rebalance,
        TRADE_FREQ,
        time_rules.market_open(minutes=1),
    )

    # Record tracking variables at the end of each day.
    schedule_function(
        record_vars,
        date_rules.every_day(),
        time_rules.market_close(),
    )

    # Set up universe, alphas and ML pipline
    context.universe = Q1500US()
    # if you are using IsAnnouncedAcqTarget, uncomment the next line
    # context.universe &= IsAnnouncedAcqTarget()

    ml_pipeline = make_ml_pipeline(
        context.universe,
        n_forward_days=PRED_N_FORWARD_DAYS,
        window_length=ML_TRAINING_WINDOW,
    )
    # Create our dynamic stock selector.
    attach_pipeline(ml_pipeline, 'alpha_model')

    context.past_predictions = {}
    context.hold_out_accuracy = 0
    context.hold_out_log_loss = 0
    context.hold_out_returns_spread_bps = 0

def evaluate_and_shift_hold_out(output, context):
    # Look at past predictions to evaluate classifier accuracy on hold-out data
    # A day has passed, shift days and drop old ones
    context.past_predictions = {
        k - 1: v
        for k, v in context.past_predictions.iteritems()
        if k > 0
    }

    if 0 in context.past_predictions:
        # Past predictions for the current day exist, so we can use todays'
        # n-back returns to evaluate them
        raw_returns = output['Returns']
        raw_predictions = context.past_predictions[0]

        # Join to match up equities
        returns, predictions = raw_returns.align(raw_predictions, join='inner')

        # Binarize returns
        returns_binary = returns > returns.median()
        predictions_binary = predictions > 0.5

        # Compute performance metrics
        context.hold_out_accuracy = metrics.accuracy_score(
            returns_binary.values,
            predictions_binary.values,
        )
        context.hold_out_log_loss = metrics.log_loss(
            returns_binary.values,
            predictions.values,
        )
        long_rets = returns[predictions_binary == 1].mean()
        short_rets = returns[predictions_binary == 0].mean()
        context.hold_out_returns_spread_bps = (long_rets - short_rets) * 10000

    # Store current predictions
    context.past_predictions[PRED_N_FORWARD_DAYS] = context.predicted_probs


def before_trading_start(context, data):
    """
    Called every day before market open.
    """
    output = pipeline_output('alpha_model')
    context.predicted_probs = output['ML']
    context.predicted_probs.index.rename(['date', 'equity'], inplace=True)

    context.risk_factors = pipeline_output('alpha_model')[['Sector']]
    context.risk_factors.index.rename(['date', 'equity'], inplace=True)
    context.risk_factors.Sector = context.risk_factors.Sector.map(
        Sector.SECTOR_NAMES,
    )

    evaluate_and_shift_hold_out(output, context)

    # These are the securities that we are interested in trading each day.
    context.security_list = context.predicted_probs.index

def rebalance(context, data):
    """
    Execute orders according to our schedule_function() timing.
    """
    predictions = context.predicted_probs
    # print("predictions")
    # print(predictions)
    
 
    

    #print(predictions)
    #stop_long_list=pipeLine[ (pipeLine['long'])].stop_long
    #short_list = pipeLine[ (pipeLine['short'])].index
    # stop_short_list=pipeLine[ (pipeLine['short'])].stop_short
    # print("000000000000000000000000000000000000000000000000000000000000")
    
    # print(predictions.index)
    # print(long_list)
    
    # print("000000000000000000000000000000000000000000000000000000000000\n")
    
    #Hello00000000000000000enbd
    

    # Filter out stocks that can not be traded
    predictions = predictions.loc[data.can_trade(predictions.index)]
    # Select top and bottom N stocks
    n_long_short = min(N_STOCKS_TO_TRADE // 2, len(predictions) // 2)
    predictions_top_bottom = pd.concat([
        predictions.nlargest(n_long_short),
        predictions.nsmallest(n_long_short),
    ])
    

    # If classifier predicts many identical values, the top might contain
    # duplicate stocks
    predictions_top_bottom = predictions_top_bottom.iloc[
        ~predictions_top_bottom.index.duplicated()
    ]
    
    maxMama=predictions.max()
    minMama=predictions.min()
    
    print("hello max"+str(maxMama)+"hello min"+str(minMama))
    
    

    print("==========================================LAST mAMA lAST")
    print(predictions_top_bottom)
    print("==========================================")
    
    


    print("==============0 to 1 this time================")
    print(predictions_top_bottom)
    print("==========================================")
    
    # Setup Optimization Objective
    objective = opt.MaximizeAlpha(predictions_top_bottom)

    # Setup Optimization Constraints
    constrain_gross_leverage = opt.MaxGrossExposure(1.0)
    constrain_pos_size = opt.PositionConcentration.with_equal_bounds(
        -0.02,
        +0.02,
    )
    market_neutral = opt.DollarNeutral()

    if predictions_top_bottom.index.duplicated().any():
        log.debug(predictions_top_bottom.head())

    sector_neutral = opt.NetGroupExposure.with_equal_bounds(
        labels=context.risk_factors.Sector.dropna(),
        min=-0.0001,
        max=0.0001,
    )

    # Run the optimization. This will calculate new portfolio weights and
    # manage moving our portfolio toward the target.
    order_optimal_portfolio(
        objective=objective,
        constraints=[
            constrain_gross_leverage,
            constrain_pos_size,
            market_neutral,
            sector_neutral,
        ],
    )
    
    
    

def record_vars(context, data):
    """
    Plot variables at the end of each day.
    """
    record(
        leverage=context.account.leverage,
        hold_out_accuracy=context.hold_out_accuracy,
        hold_out_log_loss=context.hold_out_log_loss,
        hold_out_returns_spread_bps=context.hold_out_returns_spread_bps,
    )
    

def handle_data(context, data):
    pass